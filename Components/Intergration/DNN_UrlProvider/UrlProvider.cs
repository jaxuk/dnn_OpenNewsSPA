using DotNetNuke.Entities.Urls;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using DotNetNuke.Entities.Portals;
using DotNetNuke.Entities.Tabs;
using System.Collections.Specialized;
using DotNetNuke.Services.Log.EventLog;
using System.Text.RegularExpressions;
using DotNetNuke.Entities.Users;
using System.Collections;
using YeditUK.Modules.dnn_OpenNews.Components.Intergration.DNN_UrlProvider.Entities;
using DotNetNuke.Entities.Modules;

namespace YeditUK.Modules.dnn_OpenNews.Components.Intergration.DNN_UrlProvider
{
  public class UrlProvider : ExtensionUrlProvider
  {
    protected bool _initialized = false; //whether portal settings of provider are read in
    FriendlyUrlOptions _options = null; //local copy of the Friendly Url Options, which control things like the inclusion of hyphens instead of spaces, etc.
                                        //the following set of members are specific to this module, and are used to control how the module provider works.
    protected string _ignoreRedirectRegex;//-a regex pattern to ignore certain Urls that will not be redirected
    private EventLogController _eventLogController;
    private Dictionary<int, ModuleUrlOptions> _dicModuleUrlOptions = new Dictionary<int, ModuleUrlOptions>();

    public UrlProvider(): base()
    {
      _eventLogController = new EventLogController();
    }
    private bool IsInitialized()
    {
      //look for an attribute specifying which tab the module
      //will not use a page path for.  There can only be one
      //tab specified per portal (because there is no page path, then it
      //can only be a single page, as the way of determining one dnn
      //page from another isn't in the reuqested Url)
      if (_initialized == false)
      {
        _eventLogController.AddLog("Message", "OpenNews URL Provider being intialised", PortalSettings.Current, -1, EventLogController.EventLogType.ADMIN_ALERT);
        var attributes = this.GetProviderPortalSettings();
        //_ignoreRedirectRegex = attributes["ignoreRedirectRegex"];

        //Get Module Url Options from Modules
        //Get ModuleUrlOptions for all modules.
        var modules = ModuleController.Instance.GetModulesByDefinition(PortalSettings.Current.PortalId, "dnn_OpenNewsSPA").Cast<ModuleInfo>().ToList();
        modules.ForEach(mi=> {
          var urlOpts = new ModuleUrlOptions(mi.TabID, mi.ModuleID);
          var modSettings = SettingsController.Instance.GetSettings(mi, PortalSettings.Current);
          urlOpts.RemovePagePathFromURL = modSettings.SEORemovePagePathFromURL;
          _dicModuleUrlOptions.Add(mi.TabID, urlOpts);
        });

        _initialized = true;
      }
      return _initialized;

    }

    public override bool AlwaysUsesDnnPagePath(int portalId)
    {
      return true;//no specific exceptions, return true every time
    }

    internal new string CleanNameForUrl(string title, FriendlyUrlOptions options)
    {
      bool replaced = false;
      //the base module Url PRovider contains a Url cleaning routine, which will remove illegal and unwanted characters from a string, using the specific friendly url options
      return base.CleanNameForUrl(title, options, out replaced);
    }

    internal string EnsureLeadingChar(string p, string path)
    {
      return base.EnsureLeadingChar(p, path);
    }

    /// <summary>
    /// The Change Friendly Url method is called for every Url generated when a page is generated by DotNetNuke.  This call sits 'underneath' the 'NavigateUrl' call in DotNetNuke.
    /// Whenever your module calls NavigateUrl, this method will be also called.  In here, the module developer should modify the friendlyUrlPath to the final state required.
    /// However, because this call is used for all Urls on the page, not just those generated by the target module, some type of high-level filter should be used to make sure only
    /// the module Urls are modified.
    /// 
    /// </summary>
    /// <param name="tab">Current Tab</param>
    /// <param name="friendlyUrlPath">Current Friendly Url Path after going through the Friendly Url Generation process of the Url Master module.</param>
    /// <param name="options">The options currently applying to Urls in this portal (space replacement, max length, etc)</param>
    /// <param name="cultureCode">The culture code being used for this Url (if supplied, may be empty)</param>
    /// <param name="endingPageName">The page name the Url has been called with. Normally default.aspx, but may be different for some modules.</param>
    /// <param name="useDnnPagePath">Out parameter to be set by the module.  If true, the path of the DNN page will be in the Url (ie /pagename).  If false, this part of the Url will be removed. </param>
    /// <param name="messages">List of debug messages.  Add any debug information to this collection to help debug your provider.  This can be seen in the repsonse headers, and also in the 'test Url Rewrite' page in the Url Master module.</param>
    /// <returns></returns>
    public override string ChangeFriendlyUrl(TabInfo tab, string friendlyUrlPath, FriendlyUrlOptions options, string cultureCode, ref string endingPageName, out bool useDnnPagePath, ref List<string> messages)
    {
      IsInitialized();
      _options = options;//keep local copy of options
      useDnnPagePath = true;
      ModuleUrlOptions urlOptions = GetModuleUrlOptions(tab.TabID);
      if (messages == null) messages = new List<string>();
      bool replacementFound = false;
      if (Regex.IsMatch(friendlyUrlPath, @"(^|/)(mid|moduleId)/\d+/?", RegexOptions.IgnoreCase) == false) {
        if (!replacementFound)
        {
          Regex articleUrlRegex = new Regex(@"((?<l>/)?articleType/ArticleView/articleId/|/id/)(?<artid>\d+)(/PageId/(?<pageid>\d+))?(/categoryId/(?<catid>\d+))?", RegexOptions.IgnoreCase);
          Match articleUrlMatch = articleUrlRegex.Match(friendlyUrlPath);
          if (articleUrlMatch.Success)
          {
            string articleUrl = "";
            replacementFound = UrlController.MakeArticleUrl(this, articleUrlMatch, articleUrlRegex, friendlyUrlPath, tab, options, urlOptions, cultureCode, ref endingPageName, ref useDnnPagePath, ref messages, out articleUrl);
            if (replacementFound)
              friendlyUrlPath = articleUrl;
          }
        }
        if (!replacementFound)
        {
          //no match on article  - next check is for a category match 
          Regex categoryUrlRegex = new Regex(@"(?<l>/)?articleType/CategoryView/categoryId/(?<catid>\d+)", RegexOptions.IgnoreCase);
          Match categoryUrlMatch = categoryUrlRegex.Match(friendlyUrlPath);
          if (categoryUrlMatch.Success)
          {
            string categoryUrl = "";
            replacementFound = UrlController.MakeCategoryUrl(this, categoryUrlMatch, categoryUrlRegex, friendlyUrlPath, tab, options, urlOptions, cultureCode, ref endingPageName, ref useDnnPagePath, ref messages, out categoryUrl);
            if (replacementFound)
              friendlyUrlPath = categoryUrl;
          }
        }
        if (!replacementFound)
        {
          //no match on article  - next check is for a category match 
          Regex authorUrlRegex = new Regex(@"(?<l>/)?articleType/AuthorView/authorId/(?<authid>\d+)", RegexOptions.IgnoreCase);
          Match authorUrlMatch = authorUrlRegex.Match(friendlyUrlPath);
          if (authorUrlMatch.Success)
          {
            string authorUrl = "";
            replacementFound = UrlController.MakeAuthorUrl(this, authorUrlMatch, authorUrlRegex, friendlyUrlPath, tab, options, urlOptions, cultureCode, ref endingPageName, ref useDnnPagePath, ref messages, out authorUrl);
            if (replacementFound)
              friendlyUrlPath = authorUrl;
          }
        }
        if (!replacementFound)
        {
          Regex archiveUrlRegex = new Regex(@"(?<l>/)?articleType/ArchiveView(?<mth>/month/(?<mm>\d+))?(?<yr>/year/(?<yyyy>\d+))?", RegexOptions.IgnoreCase);
          Match archiveUrlMatch = archiveUrlRegex.Match(friendlyUrlPath);
          if (archiveUrlMatch.Success)
          {
            string archiveUrl = "";
            replacementFound = UrlController.MakeArchiveUrl(this, archiveUrlMatch, archiveUrlRegex, friendlyUrlPath, tab, options, urlOptions, cultureCode, ref endingPageName, ref useDnnPagePath, ref messages, out archiveUrl);
            if (replacementFound)
              friendlyUrlPath = archiveUrl;
          }
        }
      }
      
        
      return friendlyUrlPath;
    }

    private ModuleUrlOptions GetModuleUrlOptions(int tabID)
    {
      ModuleUrlOptions ret = new ModuleUrlOptions();
      
      if (_dicModuleUrlOptions.ContainsKey(tabID)) {
        return _dicModuleUrlOptions[tabID];
      }
      else {
        return new ModuleUrlOptions(tabID, -1);
      } 
    }

    /// <summary>
    /// Determines when to do a redirect.  This is separate to the rewriting process.  The module developer can create any type of Url redirect here, because the entire Url of the original request is passed in.
    /// </summary>
    /// <param name="tabId">Identified TabId, if known.  -1 if no valid tabid identified.</param>
    /// <param name="portalid">Identified portalId.</param>
    /// <param name="httpAlias">Identified httpAlias of the request.</param>
    /// <param name="requestUri">The original requested Url</param>
    /// <param name="queryStringCol">The querystring collection of the original request</param>
    /// <param name="options">The friendly url options that currently apply.</param>
    /// <param name="redirectLocation">Out parameter that shows where to redirect to.</param>
    /// <param name="messages">List of messages for debug purposes.  Add to this list to help debug your module.</param>
    /// <returns>true if 301 redirect is required, false if not.  If true, the redirectLocation value must be a valid fully qualified Url.</returns>
    public override bool CheckForRedirect(int tabId, int portalid, string httpAlias, Uri requestUri, NameValueCollection queryStringCol, FriendlyUrlOptions options, out string redirectLocation, ref List<string> messages)
    {
      bool doRedirect = false;
      if (messages == null) messages = new List<string>();
      redirectLocation = "";//set blank location
                            //compare to known pattern of old Urls
      if (true)
      {
        Regex oldNewsRegex = new Regex(@"(&articleType=(?<type>[^&]+))?((&(?<idname>[a-z]*Id)=(?<id>\d+))|((&month=(?<mm>[\d]{1,2}))?&year=(?<yyyy>[\d]{4})))(&(?<pgname>PageId|CurrentPage)=(?<pg>[\d]+))?", RegexOptions.IgnoreCase);
        Match oldNewsMatch = oldNewsRegex.Match(queryStringCol.ToString());
        if (oldNewsMatch.Success)
        {
          Group typeGroup = oldNewsMatch.Groups["type"];
          Group idNameGroup = oldNewsMatch.Groups["idname"];
          Group idGroup = oldNewsMatch.Groups["id"];
          Group pageGroup = oldNewsMatch.Groups["pg"];
          Group pgNameGrp = oldNewsMatch.Groups["pgname"];
          string msg = "";
          string id = null;
          string furlKey = null;
          string friendlyUrl = null;
          if (idGroup != null && idGroup.Success)
            id = idGroup.Value;
          string idType = null;
          if (typeGroup != null && typeGroup.Success)
          {
            idType = typeGroup.Value.ToLower();
          }
          else
          {
            if (idNameGroup != null && idNameGroup.Success)
            {
              //check if it's the 'ID' value
              if (idNameGroup.Value.ToLower() == "id")
                idType = "id";
            }
          }
          //now look at the idType
          string pagePath = null;
          if (pgNameGrp != null && pgNameGrp.Success == true && pageGroup != null && pageGroup.Success)
          {
            pagePath = pgNameGrp.Value + "/" + pageGroup.Value;
          }
          switch (idType)
          {
            case "articleview":
            case "id":
              msg = "Identified as old-style news article";
              //article
              if (pageGroup != null && pageGroup.Success)
              {
                furlKey = "p" + pageGroup.Value;
                pagePath = null; //taking care of page separately
              }
              else
              {
                int articleId = -1;
                //only for items that are in the range of allowed article ids
                if (int.TryParse(id, out articleId))
                {
                    furlKey = "a" + id;
                }
              }

              break;
            case "categoryview":
              msg = "Identified as old-style news category";
              furlKey = "c" + id;
              break;
            case "archiveview":
              //get the mm and yyyy
              msg = "Identified as old-style news archive";
              Group yyyyGrp = oldNewsMatch.Groups["yyyy"];
              if (yyyyGrp != null && yyyyGrp.Success)
              {
                string yyyy = yyyyGrp.Value;
                string mm = null;
                Group mmGrp = oldNewsMatch.Groups["mm"];
                if (mmGrp != null && mmGrp.Success)
                {
                  mm = mmGrp.Value;
                }
                friendlyUrl = yyyy;
                if (mm != null)
                  friendlyUrl += "/" + mm;
              }
              break;
            case "authorview":
              msg = "Identified as old-style news author";
              furlKey = "u" + id;
              break;
          }
          if (furlKey != null)
          {
            //now lookup the friendly url index
            ModuleUrlOptions urlOptions = GetModuleUrlOptions(tabId);
            Hashtable friendlyUrlIndex = UrlController.GetFriendlyUrlIndex(tabId, portalid, this, options, urlOptions);
            if (friendlyUrlIndex != null && friendlyUrlIndex.ContainsKey(furlKey))
            {
              //look up the index for the item if we don't already have a friendly Url
              friendlyUrl = (string)friendlyUrlIndex[furlKey];
            }
          }
          if (friendlyUrl != null)
          {
            //now merge with the friendly url for the selected page
            PortalAliasInfo alias = PortalAliasController.GetPortalAliasInfo(httpAlias);
            PortalSettings ps = new PortalSettings(tabId, alias);
            if (pagePath != null)
              friendlyUrl += this.EnsureLeadingChar("/", pagePath);
            string baseUrl = "";
            ModuleUrlOptions urlOptions = GetModuleUrlOptions(tabId);
            if (urlOptions.RemovePagePathFromURL)
            {
              baseUrl = requestUri.Scheme + Uri.SchemeDelimiter + httpAlias + this.EnsureLeadingChar("/", friendlyUrl) + options.PageExtension;//put onto http Alias with no page path
            }
            else
              baseUrl = DotNetNuke.Common.Globals.NavigateURL(tabId, ps, "", friendlyUrl); //add on with page path
            if (baseUrl != null)
            {
              redirectLocation = baseUrl;
              doRedirect = true;
              msg += ", found friendly url " + friendlyUrl + ", redirecting";
              messages.Add(msg);
            }
          }

        }

      }
      return doRedirect;
    }

    /// <summary>
    /// Returns any custom settings that are specific per-portal for this instance
    /// </summary>
    /// <remarks>
    /// This is used to write the values back out to the web.config from the Url Master UI
    /// </remarks>
    /// <returns>A Dictionary of the key/value pairs of the settings used in this provider.  Return empty dictionary if no portal specific options.</returns>
    public override Dictionary<string, string> GetProviderPortalSettings()
    {
      return new Dictionary<string, string>();
      //throw new NotImplementedException();
    }
    /// <summary>
    /// This method is used by the Url Master Url Rewriting process.  The purpose of this method is to take the supplied array of Url parameters, and transform them into a module-specific querystring for the underlying re-written Url.
    /// </summary>
    /// <param name="urlParms">The array of parameters found after the DNN page path has been identified.  No key/valeu pairs are identified, the parameters are converted from the /key/value/key2/value2 format into [key,value,key2,value2] format.</param>
    /// <param name="tabId">TabId of identified DNN page. </param>
    /// <param name="portalId">PortalId of identified DNN portal.</param>
    /// <param name="options">The current Friendly Url options being used by the module.</param>
    /// <param name="cultureCode">Identified language/culture code, if supplied.</param>
    /// <param name="portalAlias">Identified portalAlias object for the request.</param>
    /// <param name="messages">List of debug messages.  Add to this list to help debug your module.  Can be viewed in the reponse headers of the request, or in the 'Test Url Rewriting' section of the Url Master module.</param>
    /// <param name="status">Out parameter, returns the Http status of the request.  May be 200,301,302, or 404.  For normal rewriting, return a 200 value.</param>
    /// <param name="location">If a 301 or 302 is returned in the status parameter, then this must contain a valid redirect location.  This should be a fully-qualified Url.</param>
    /// <returns>The querystring to be used for rewriting the Url. NOTE: doesn't need to include the tabid if the tabid parameter is > -1</returns>
    public override string TransformFriendlyUrlToQueryString(string[] urlParms, int tabId, int portalId, FriendlyUrlOptions options, string cultureCode, PortalAliasInfo portalAlias, ref List<string> messages, out int status, out string location)
    {
      string path = string.Join("/", urlParms);
      //initialise results and output variables
      location = null; //no redirect location
      if (messages == null) messages = new List<string>();
      string result = ""; status = 200; //OK 
      _options = options;
      ModuleUrlOptions urlOptions = GetModuleUrlOptions(tabId);
      Hashtable queryStringIndex = null;
      int skipUpToIndex = -1;
      bool found = false;
      bool siteRootMatch = false;
      bool tabHasNAModule = false;
      //foreach (ModuleInfo mi in ModuleController.Instance.GetTabModules(tabId).Values) {

      //}
      if ((from ModuleInfo mi in ModuleController.Instance.GetTabModules(tabId).Values where mi.DesktopModule.FolderName.ToLower().Contains("dnn_opennewsspa") select mi.ModuleTitle).Count() != 0)
      {
        tabHasNAModule = true;
      }
      //prevent incorrect matches of Urls
      if (!Regex.IsMatch(path, @"(articleType/(?<type>[^/]+))|(ctl/[^/]+/(mid|moduleid)/\d)", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant)) {
        if (urlParms.Length > 0)
        {
          //tabid == -1 when no dnn page path is in the Url.  This means the Url Master module can't determine the DNN page based on the Url.
          //In this case, it is up to this provider to identify the correct tabId that matches the Url.  Failure to do so will result in the incorrect tab being loaded when the page is rendered. 
          if (tabId == -1)
          {
            siteRootMatch = true;
            //if (_noDnnPagePathTabId > -1) {
            //  //tabid -1 means a 'site root' match - meaning that the dnn page path wasn't included in the Url
            //  tabId = _noDnnPagePathTabId;//if tabid = -1, it means a site root match (no dnn page path) so we substitute in the tabid where this is being used
            //}
          }
          queryStringIndex = UrlController.GetQueryStringIndex(tabId, portalId, this, options, urlOptions, false);
          string pathBasedKey = string.Join("/", urlParms).ToLower();
          string qs = null;
          if (queryStringIndex.ContainsKey(pathBasedKey))
          {
            //that was easy-  direct match
            qs = (string)queryStringIndex[pathBasedKey];
            skipUpToIndex = urlParms.GetUpperBound(0);
          }
          else
          {
            //go through the parameter list backwards until we find a match
            for (int i = urlParms.GetUpperBound(0); i >= 0; i--)
            {
              //copy all the array minus the i index item
              int tempLength = i + 1;
              string[] tempParms = new string[tempLength];
              Array.Copy(urlParms, 0, tempParms, 0, i + 1);
              //make a new key from the shorter array
              pathBasedKey = string.Join("/", tempParms).ToLower();
              //check if that matches
              if (queryStringIndex.ContainsKey(pathBasedKey))
              {
                qs = (string)queryStringIndex[pathBasedKey];
                if (qs != null)
                {
                  //the trimmed pieces need to be included
                  skipUpToIndex = i;
                  break;
                }
              }
            }
          }
          if (qs != null)
          {
            //found a querystring match
            found = true;
            messages.Add("Item Matched in Friendly Url Provider.  Url : " + pathBasedKey + " Path : " + path);
            result += qs;
          }
          //else
          //{
          //  //no match, but look for a date archive pattern
          //  //903 : issue with matching other Urls that aren't archive Urls
          //  Regex archivePatternRegex = new Regex(@"(?<!year)(?<yr>(^|/)(?<yyyy>[\d]{4}))(?<mth>/(?<mm>[\d]{1,2}))?", RegexOptions.IgnoreCase);
          //  Match archivePatternMatch = archivePatternRegex.Match(path);
          //  if (archivePatternMatch.Success)
          //  {
          //    bool month = false, year = false;
          //    string mm = null, yyyy = null;
          //    //matched on date pattern, extract month/year
          //    Group mthGrp = archivePatternMatch.Groups["mth"];
          //    if (mthGrp != null && mthGrp.Success)
          //    {
          //      mm = archivePatternMatch.Groups["mm"].Value;
          //      month = true;
          //    }
          //    Group yrGrp = archivePatternMatch.Groups["yyyy"];
          //    if (yrGrp != null && yrGrp.Success)
          //    {
          //      //902 : don't allow invalid dates to be passed down
          //      int yearVal = 0;
          //      yyyy = yrGrp.Value;
          //      //check that year is a valid int, and that year is later than sql min date time
          //      if (int.TryParse(yyyy, out yearVal) && yearVal > 1753 && tabHasNAModule)
          //      {
          //        year = true;
          //      }
          //    }
          //    if (year)
          //    {
          //      qs = "";
          //      if (urlOptions.RemovePagePathFromURL) {
          //        qs += "?tabid=" + tabId.ToString();
          //      }
          //        //if (this.NoDnnPagePathTabId == tabId)
          //        //qs += "?tabid=" + tabId.ToString();
          //      //add on the year
          //      qs += "&articleType=ArchiveView&year=" + yyyy;
          //      skipUpToIndex = 0;//1st position
          //    }
          //    if (year && month)
          //    {
          //      int mmVal = 0;
          //      if (int.TryParse(mm, out mmVal) && mmVal > 0 && mmVal < 13)
          //      {
          //        qs += "&month=" + mm;
          //        skipUpToIndex = 1;//2nd position 
          //      }
          //    }
          //    if (year || month)
          //    {
          //      result += qs;
          //    }
          //  }
          //}
          if (skipUpToIndex >= 0)
          {
            //put on any remainder of the path that wasn't to do with the friendly Url
            //but only if there was *something* in the friendly url that we interpreted
            string remainder = base.CreateQueryStringFromParameters(urlParms, skipUpToIndex);
            //put it all together for the final rewrite string
            result += remainder;
          }
        }
      }
      return result;
    }
  }
}